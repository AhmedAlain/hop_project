#!/usr/bin/python3

import tf
import math
import time
import rospy
import random
import numpy as np
import heapq
from queue import PriorityQueue
from std_msgs.msg import ColorRGBA
from sklearn.cluster import DBSCAN
from scipy.ndimage import binary_dilation
from nav_msgs.msg import Odometry, OccupancyGrid
from visualization_msgs.msg import Marker, MarkerArray
from utils_lib.online_planning import StateValidityChecker, move_to_point
from geometry_msgs.msg import Twist, Point, PoseStamped, Pose, Quaternion, Vector3

class OnlinePlanner:

    # OnlinePlanner Constructor
    def __init__(self, gridmap_topic, odom_topic, cmd_vel_topic, dominion, distance_threshold):

        # ATTRIBUTES
        # List of points which define the plan. None if there is no plan
        self.path = []
        # State Validity Checker object                                                
        self.svc = StateValidityChecker(distance_threshold)
        # Current robot SE2 pose [x, y, yaw], None if unknown            
        self.current_pose = None
        # Goal where the robot has to move, None if it is not set                                                                  
        self.goal = None
        # Last time a map was received (to avoid map update too often)                                                
        self.last_map_time = rospy.Time.now()
        # Dominion [min_x_y, max_x_y] in which the path planner will sample configurations                          
        self.dominion = dominion
        # Grid map
        self.grid_map = None
        # Origin of the map
        self.origin = None
        # Resolution of the map
        self.resolution = None                                

        # CONTROLLER PARAMETERS
        # Proportional linear velocity controller gain
        self.Kv = 0.5
        # Proportional angular velocity controller gain                  
        self.Kw = 0.5
        # Maximum linear velocity control action                  
        self.v_max = 0.15
        # Maximum angular velocity control action              
        self.w_max = 0.3

        # FRONTIERS PARAMETERS
        # List of centroids
        self.centroids = None
        # Index of centroid to be deleted
        self.ind = None
        # List of centroids to copy
        self.centroids_all = None
        # List of clusters of frontiers
        self.frontier_clusters = None       

        # PUBLISHERS
        # Publisher for sending velocity commands to the robot
        self.cmd_pub = rospy.Publisher(cmd_vel_topic, Twist, queue_size=10)
        # Publisher for visualizing the path to with rviz
        self.marker_pub = rospy.Publisher('~path_marker', Marker, queue_size=1)
       
        # SUBSCRIBERS
        # Subscriber to gridmap_topic from Octomap Server  
        self.gridmap_sub = rospy.Subscriber(gridmap_topic, OccupancyGrid, self.get_gridmap)
        # Subscriber to odom_topic 
        self.odom_sub = rospy.Subscriber(odom_topic, Odometry, self.get_odom)
        # Subscriber to /move_base_simple/goal published by rviz
        self.move_goal_sub = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.get_goal)
        #  Subscriber to the frontiers lists
        self.marker_frontier_list_pub = rospy.Publisher('frontier_list', MarkerArray,queue_size=10)
        # Subscriber to the centroids list 
        self.marker_centroied_list_pub = rospy.Publisher('centroied_list', MarkerArray,queue_size=10)
        # Subscriber to the next goal position
        self.marker_goal_pub = rospy.Publisher('goal_marker', Marker,queue_size=10)   
        # Subscriber to the DWA best velocity and angular velocity
        self.marker_v_w_pub = rospy.Publisher('v_w_marker', Marker,queue_size=10)
        # Subscriber to the heading being passed to the DWA
        self.dwa_heading_pub = rospy.Publisher('dwa_heading', Marker,queue_size=10)
        # Subscriber to the tree generated by the DWA prior to selection
        self.dwa_tree_pub = rospy.Publisher('dwa_tree', MarkerArray,queue_size=10)
        # Subscriber to a pointer to the location of the next goal from the robot
        self.dwa_goal_heading_pub = rospy.Publisher('dwa_goal_heading', Marker,queue_size=10)
        
        # Motions for Frontier Algorithm
        left = np.array([-1, 0])
        right = np.array([1, 0])
        up = np.array([0, 1])
        down = np.array([0, -1])

        top_right = np.array([1, 1])
        bot_right = np.array([1, -1])
        top_left = np.array([-1, 1])
        bot_left = np.array([-1, -1])

        self.motion4 = [left, right, up, down]
        self.motion8 = [left, right, up, down, top_right, bot_right, top_left, bot_left]

        self.f = True

        # TIMERS
        time.sleep(2)
        # Timer for velocity controller
        
        rospy.Timer(rospy.Duration(0.1), self.controller)

    # Odometry callback: Gets current robot pose and stores it into self.current_pose
    def get_odom(self, odom):
        _, _, yaw = tf.transformations.euler_from_quaternion([odom.pose.pose.orientation.x,
                                                              odom.pose.pose.orientation.y,
                                                              odom.pose.pose.orientation.z,
                                                              odom.pose.pose.orientation.w])
        self.current_pose = np.array([odom.pose.pose.position.x, odom.pose.pose.position.y, yaw])
        self.current_vel = np.array([odom.twist.twist.linear.x, odom.twist.twist.angular.z])

    # Goal callback: Get new goal from /move_base_simple/goal topic published by rviz
    # and computes a plan to it using self.plan() method
    def get_goal(self, goal):
        if self.svc.there_is_map:
            print("New goal received: ({}, {})".format(goal.pose.position.x, goal.pose.position.y))
            self.goal = np.array([goal.pose.position.x, goal.pose.position.y])
             # to send zero velocity while planning
            if self.svc.is_valid(self.goal):
                self.path = None                                                   
                self.path = self.plan()
            else:
                print("the goal is unvalid")
       
    # Map callback:  Gets the latest occupancy map published by Octomap server and update
    # the state validity checker
    def get_gridmap(self, gridmap):
     
        if (gridmap.header.stamp - self.last_map_time).to_sec() > 1:            
            self.last_map_time = gridmap.header.stamp

            # Update State Validity Checker
            env = np.array(gridmap.data).reshape(gridmap.info.height, gridmap.info.width).T
            self.grid_map = env

            origin = [gridmap.info.origin.position.y, gridmap.info.origin.position.x]
            self.origin = origin

            res = gridmap.info.resolution
            self.resolution = res

            self.svc.set(env,res , origin)
            
            if self.centroids is not None:
                self.exploration(self.centroids, res, origin, self.frontier_clusters)
            
            #Implimenting Froniter Algorithm
            elif self.f:
                frontiers_list = self.find_frontiers(env)
                frontiers_prune = self.prune(frontiers_list)
                self.f_marker(frontiers_prune, res,origin)
                self.frontier_clusters = self.cluster(frontiers_prune)
                centroids = self.centroid_list(self.frontier_clusters)
                self.centroids_all = centroids
                if centroids ==[] or centroids is None:
                    while True:
                        print("Exploration finished. All the remaining areas with frontiers are not reachable by the robot.")
                
                self.f_centroide(centroids, res, origin)
                self.exploration(centroids, res, origin, self.frontier_clusters)

    # Exploration function to determine next goal or if exploration is done       
    def exploration(self, centroids, res, origin, clusters):

        goal = self.select_cluster_with_highest_frontier(centroids, clusters)
        cent = centroids.copy()
        
        for j in range(len(cent)):
                if np.all(goal == cent[j]):
                    self.ind = j
                    break # Exit the loop after deleting the centroid
        
        self.centroids = cent.copy()
        self.f_goal(goal, res, origin)  ## <-- in bit!!

        goal = self.svc.move_centroide(goal)
        goal = self.__map_to_position__(goal,res , origin)
        goal = self.svc.move_centroide(goal)

        if len(cent) > 0:
            print("testing if", goal, "is valid!\n")

            self.path = None
            self.goal = goal                                                   
            self.path = self.plan()

            if self.path is not None:
                self.centroids = None
                self.f = False
                self.centroids_all = None
            # self.ind = None
        else:
            if len(cent) > 1:

                del cent[self.ind]
                self.centroids = cent.copy()
                
                print("current self.centroids:",self.centroids)
            else:
                while True:
                    print("Exploration finished. All the remaining areas with frontiers are not reachable by the robot.")

    # Solve plan from current position to self.goal.
    def plan(self):
        # List of waypoints [x, y] that compose the plan
        path = []
        threshold_values = [0.5]

        print("Compute new path")

        # TODO: plan a path from self.current_pose to self.goal
        astar_start = tuple(self.current_pose)
        astar_goal = (self.goal[0], self.goal[1], 0)

        for threshold in threshold_values:
            print("for a values of: ", threshold)
            if path  == []:
                path = self.hybrid_a_star(self.grid_map, astar_start, astar_goal, threshold)

        self.path = path 
        
        print("path: ", path)

        if path == [] or path is None:
            # If planning fails, consider increasing the planning time
            print("Path not found!")
            del self.centroids[self.ind]

            return None
            #print("cent del",self.centroids)

        else:
            print("Path found")
            # Publish plan marker to visualize in rviz
            self.publish_path(path)
            # remove initial waypoint in the path (current pose is already reached)
            if path == []:
                pass
            else:
                del path[0]    

        return path

    def all_points_are_free(self, path, gridmap):
        for point in path:
            bit_goal = self.__position_to_map__(point)
            if not self.within_bounds(bit_goal, gridmap):
                print("OBSTACLE FOUND")
                return False
        
        return True

    # This method is called every 0.1s. It computes the velocity comands in order to reach the
    # next waypoint in the path. It also sends zero velocity commands if there is no active path.
    def controller(self, event):
        v = 0
        w = 0
       
        if self.path is not None and len(self.path) > 0:

            # If current wait point reached with some tolerance move to next way point, otherwise move to current point
            if np.linalg.norm(self.path[0] - self.current_pose[0:2]) < 5*self.svc.resolution:
                print("Position {} reached".format(self.path[0]))
                del self.path[0]
                if len(self.path) == 0:
                    self.goal = None
                    print("final position reached!")
                    self.__send_commnd__(0,0)
                    self.f = True
            else:
                # Implement hybrid controller
                v_max = 0.5     # m/s
                w_max = 1.0     # rad/s

                dv_resolution = 0.1  # m/s
                dw_resolution = 0.49   # rad/s
                dt = 0.24        # s
                t_total = 1.0   # s

                best_v, best_w = self.dynamic_window_approach(self.path[0], v_max, w_max, dv_resolution, dw_resolution, dt, t_total)
                #v, w = move_to_point(self.current_pose, self.path[0])
                v = best_v
                w = best_w
                # self.cmd_pub.publish(cmd_vel)

        # Publish velocity commands
        self.__send_commnd__(v, w)

    

    ############################################################################################################################################################


    def within_bounds(self, point, inflated_map):
        if point == []:
            return False
        
        x, y = point[0], point [1]
        if x < 0 or y < 0 or x >= inflated_map.shape[0] or y >= inflated_map.shape[1]:
            return False
        else:
            return True

    def collide(self, motion, inflated_map):
        # In inflated_map, True is occupied and False is free!!
        for point in motion:
            map_point = self.__position_to_map__(point)

            #print("POINT IS:", map_point, "and", inflated_map[map_point[0], map_point[1])
            if point == [] or not self.within_bounds(map_point, inflated_map):
                return True
            else:
                return inflated_map[map_point[0], map_point[1]]

    def simulate_motion_astar(self, x, y, theta, v, w, dt):
        x += v * math.cos(theta) * dt
        y += v * math.sin(theta) * dt
        theta += w * dt
        return x, y, theta

    def create_lattice(self, inflated_map, start, v_max, w_max, time, dt):
        trajectory = []
        points = []

        for w in np.arange(-w_max, 2*w_max, w_max):
            x, y, theta = start
            motion = []

            for _ in np.arange(0, time, dt):
                x, y, theta = self.simulate_motion_astar(x, y, theta, v_max, w, dt)
                motion.append((x, y))

            if not self.collide(motion, inflated_map):
                trajectory.append(motion)
                points.append((x, y, theta))
        
        return trajectory, points

    def heuristic(self, start, goal):
        return np.sqrt((goal[0] - start[0])**2 + (goal[1] - start[1])**2)

    def goal_is_reached(self, current, goal, threshold=0.5):
        if abs(current[0] - goal[0]) < threshold and abs(current[1] - goal[1]) < threshold:
            return True

    def reconstruct_path(self, came_from, current, trajectories):
        path = []
        trajectory_order = []
        while current in came_from:
            traj_index, node = came_from[current]
            trajectory_order.append(traj_index)
            current = node

        trajectory_order.reverse()
        for traj_index in trajectory_order:
            trajectory = trajectories[traj_index]
            path.extend(trajectory)
        
        return path

    def hybrid_a_star(self, map, start, goal, threshold=0.5, heuristic_weight=4, iterations=5000):
        v_max, w_max = 0.5, 1.0
        time, dt = 0.5, 0.24
        
        radius = 5
        struct = np.ones((2*radius+1, 2*radius+1))
        inflated_map = binary_dilation(map, struct)

        all_headings_explored = False
        total_rotation = 0

        tries = 0

        # --- #

        while not all_headings_explored:
            open_set = PriorityQueue()
            open_set.put((0, start))

            came_from = {}
            g_score = {start: 0}
            f_score = {start: heuristic_weight * self.heuristic(start, goal)}

            trajectories = []
            trajectory_index = 0

            while not open_set.empty():
                tries += 1

                if tries == iterations:
                    print("number of iterations exceeded for starting point of", start)
                    break
                
                _, current = open_set.get()

                if self.goal_is_reached(current, goal):
                    path = self.reconstruct_path(came_from, current, trajectories)
                    return path

                lattice, neighbor_list = self.create_lattice(inflated_map, current, v_max, w_max, time, dt)

                if lattice == []:
                    continue

                for i, neighbor in enumerate(neighbor_list):
                    trajectory = lattice[i]
                    tentative_g_score = g_score[current] + 1

                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                        came_from[neighbor] = (trajectory_index, current)
                        g_score[neighbor] = tentative_g_score
                        f_score[neighbor] = tentative_g_score + heuristic_weight * self.heuristic(neighbor, goal)
                        open_set.put((f_score[neighbor], neighbor))

                        trajectories.append(trajectory)
                        trajectory_index += 1


            if not self.goal_is_reached(current, goal, threshold):
                if total_rotation > 2*np.pi:
                    print("no paths found :(")
                    all_headings_explored = True
                
                else:
                    start = (start[0], start[1], start[2]+np.pi/2)
                    total_rotation += np.pi/2
                    tries = 0

               

        return []  # No path found


############################################################################################################################################################


    # Finds frontiers in the grid map
    def find_frontiers(self, g_map):
        frontier_list = []
        print("finding frontiers...")

        for j, pixel_row in enumerate(g_map):
              for i, pixel in enumerate(pixel_row):
                  # Check if cell is free
                  if pixel == 0:
                      cell = np.array([i, j])
                      if self.check_frontier(cell, g_map):
                        frontier_list.append([i, j])

        print(len(frontier_list))
        frontier_list = self.remove_unknown_cells(frontier_list, g_map)  # <-- check
        print(len(frontier_list))
        print("frontiers found! publishing...")
        return frontier_list
    
    # Checks the neighbor if occupied
    def check_frontier(self, free_cell, gmap):
        for m in self.motion4:

            step = free_cell + m
            
            step[0] = max(step[0], 0)
            step[1] = max(step[1], 0)
            step[0] = min(step[0], gmap.shape[0] - 1)
            step[1] = min(step[1], gmap.shape[1] - 1)
            
            if gmap[step[1]][step[0]] == -1:
                return True
            
    # Checks the fronters if it is not surrounded by a free cell
    def remove_unknown_cells(self, frontiers, grid_map):
        surrounded_frontiers = []

        for frontier in frontiers:

            for m in self.motion4:

                step = frontier + m
                
                step[0] = max(step[0], 0)
                step[1] = max(step[1], 0) 
                step[0] = min(step[0], grid_map.shape[1] - 1) 
                step[1] = min(step[1], grid_map.shape[0] - 1)
            
                if grid_map[step[1]][step[0]] != 0:
                    surrounded_frontiers.append(frontier)
                    break

        return surrounded_frontiers
    
    # Prunes frontiers that to no form clusters
    def prune(self, frontiers):

        for f in frontiers:
            remove_f = True
            for m in self.motion8:
                step = f + m
                if self.__array_in_list(step, frontiers):
                    remove_f = False
            if remove_f:
                frontiers = self.__remove_array_from_list(f, frontiers)

        return frontiers
    
    # Creates clusters according to the neighbors of each frontier cell
    def cluster(self, frontiers):
        
        frontiers_array = np.array(frontiers)

        dbscan = DBSCAN(eps=3)
        labels = dbscan.fit_predict(frontiers_array)

        unique_labels = np.unique(labels[labels != -1])

        clusters = []
        
        for label in unique_labels:
            cluster_frontiers = frontiers_array[labels == label].tolist()

            if len(cluster_frontiers) > 6:
                clusters.append(cluster_frontiers)
            
        return clusters
    
    # Selects the best centroid according to distance and number of frontiers
    def select_cluster_with_highest_frontier(self,cen, clusters):
        max_frontier = 0
        selected_centroid = None
        for centroid in cen:
            # Get the frontier cells in the current cluster
            current_cluster_frontiers = []
            for cell in clusters[self.centroids_all.index(centroid)]:
                current_cluster_frontiers.append(cell)

            # Check if the current cluster has the highest number of frontiers
            if len(current_cluster_frontiers) > max_frontier:
                max_frontier = len(current_cluster_frontiers)
                selected_centroid = centroid
        return selected_centroid

    # Create a list of centroids given the found clusters
    def centroid_list(self, clusters):
        
        centroids = []
        cent_id = {}

        for cluster in clusters:
            n = len(cluster)
            x_i, y_i = 0, 0

            for p in cluster:
                x_i += p[0]
                y_i += p[1]
            
            x_i = int(x_i / n)
            y_i = int(y_i / n)

            min_dist = None
            closest_centroid = None

            for p in cluster:
                dist = math.sqrt((p[0]-x_i)**2 + (p[1]-y_i)**2)

                # Update min_dist and closest_centroide if this centroid is closer than the previous closest centroid
                if min_dist is None or dist < min_dist:
                    min_dist = dist
                    closest_centroid = p

            centroids.append(closest_centroid)
            cent_id[(closest_centroid[0], closest_centroid[1])] = cluster
        
        return centroids

    # Transform cell coordinates to position with respect the map origin
    def __map_to_position__(self, c,res,orig):
       # TODO: convert map coordinates to world position
       x = (c[0] * res) + orig[0]
       y = (c[1] * res) + orig[1]
       return y, x
   
    # Transform position with respect the map origin to cell coordinates
    def __position_to_map__(self, p):
        # TODO: convert world position to map coordinates. If position outside map return `[]` or `None`
        x, y = p[1], p[0]
        col = int((y - self.origin[1]) / self.resolution)
        row = int((x - self.origin[0]) / self.resolution)

        map_coord = [col, row]
        if row < 0 or col < 0 or row >= self.grid_map.shape[0] or col >= self.grid_map.shape[1]:
            return []
        return map_coord

    # Checks if a numpy array is present in a list of arrays
    def __array_in_list(self, array, list_of_arrays):
        for a in list_of_arrays:
            if np.array_equal(array, a):
                return True
        return False
    
    # Removes a numpy array from a list of arrays
    def __remove_array_from_list(self, array, list_of_arrays):
        new_list = []
        for a in list_of_arrays:
            if not np.array_equal(array, a):
                new_list.append(a)
        return new_list
    
    # Define a helper function to simulate robot motion
    def simulate_motion(self, v, w, dt, x, y, yaw):
        x += v * math.cos(yaw) * dt
        y += v * math.sin(yaw) * dt
        yaw += w * dt
        return x, y, yaw
    
    def correct_angle(self, angle):
        angle = math.fmod(angle, 2 * math.pi)
        if angle < 0:
            angle += 2 * math.pi
        
        return angle

    # Dynamic window approach algorithm to select best v and w
    def dynamic_window_approach(self, goal, v_max, w_max, dv_resolution, dw_resolution, dt, t_total): 

          grid_map = np.array(self.svc.map)

          weight_range = [0, 1]

          # Initial state
          self.current_pose
          xi, yi, theta_i = self.current_pose[0], self.current_pose[1], self.current_pose[2]
          pose = [xi, yi, theta_i]
          self.dwa_heading(pose)

          vi = 0

          goal = goal # m
          goal_theta = self.svc.compute_angle((xi, yi), goal) # rad
          goal_theta = self.correct_angle(goal_theta)

          goal_heading = [xi, yi, goal_theta]
          self.dwa_goal_heading(goal_heading)

          thresh = np.pi/6    
          angle_diff = abs(self.correct_angle(theta_i) - goal_theta)

          no_of_branches = len(np.arange(-w_max, w_max, dw_resolution))
          collision_list = [False] * no_of_branches

          # Empty lists
          trajectory = []

          speed_dict = {}
          goal_direction_dict = {}
          collision_dict = {}

          xy_to_vw = {}
          xy_list = []

          for v in np.arange(0, v_max, dv_resolution):
            for j, w in enumerate(np.arange(-w_max, w_max, dw_resolution)):
                x, y, theta = xi, yi, theta_i

                # simulate motion for the given command
                motion = []
                for _ in np.arange(0, t_total, dt):
                    x, y, theta = self.simulate_motion(v, w, dt, x, y, theta)
                    x = round(x, 2)
                    y = round(y, 2)

                    motion.append((x, y))
                    p = self.svc.__position_to_map__([y, x])
                    
                    if p == [] or grid_map[p[1], p[0]] != 0:
                        collision_list[j-1] = True
                
                trajectory.append(motion)

                #if x != xi and y!= yi:
                xy_to_vw[(x, y)] = (v, w)
                xy_list.append([x, y])

                speed_cost = v - vi
                speed_dict[(x, y)] = speed_cost

                theta = self.correct_angle(theta)

                goal_direction_cost =  abs(goal_theta - theta)
                goal_direction_dict[(x, y)] = goal_direction_cost
            
          for index, line in enumerate(trajectory):
            k = index
            while k > no_of_branches:
                k -= no_of_branches
            
            if not collision_list[k-1]:
                x, y = zip(*line)
                #if x[-1] != xi and y[-1] != yi:
                collision_cost = weight_range[1]
                collision_dict[(x[-1], y[-1])] = collision_cost
          
          self.dwa_tree(xy_list)

          # Compute weights
          new_speed_dict = self.svc.scale(speed_dict, weight_range)
          new_goal_direction_dict = self.svc.scale(goal_direction_dict, [weight_range[1], weight_range[0]])
          
          # Find best command
          result_dict = self.svc.add_dicts(new_speed_dict, new_goal_direction_dict, collision_dict)
          key_with_max_value = max(result_dict, key=result_dict.get)
          
          best_v, best_w = xy_to_vw[key_with_max_value]
          self.best_v_w_marker(key_with_max_value)

          # If goal is out of the window, switch to normal controller
          if angle_diff > thresh:
              best_v, best_w = move_to_point(self.current_pose, self.path[0])
              best_v = round(best_v, 2)
              best_w = round(best_w, 2)
        
          print("The best (v, w) command is", [best_v, best_w])
          #best_v, best_w = 0, 0

          return best_v, best_w

    # Calculates the euclidean distance between two points
    def __distance(self, p1, p2):
        return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5
    
    # PUBLISHER HELPERS
    # Transform linear and angular velocity (v, w) into a Twist message and publish it
    def __send_commnd__(self, v, w):
        cmd = Twist()
        cmd.linear.x = np.clip(v, -self.v_max, self.v_max)
        cmd.linear.y = 0
        cmd.linear.z = 0
        cmd.angular.x = 0
        cmd.angular.y = 0
        cmd.angular.z = np.clip(w, -self.w_max, self.w_max)
        self.cmd_pub.publish(cmd)

    # Publish a path as a series of line markers
    def publish_path(self, path):
        if len(path) > 1:
            print("Publish path!\n")
            m = Marker()
            m.header.frame_id = 'world_ned'
            m.header.stamp = rospy.Time.now()
            m.id = 0
            m.type = Marker.LINE_STRIP
            m.ns = 'path'
            m.action = Marker.DELETE
            m.lifetime = rospy.Duration(0)
            self.marker_pub.publish(m)

            m.action = Marker.ADD
            m.scale.x = 0.1
            m.scale.y = 0.0
            m.scale.z = 0.0
           
            m.pose.orientation.x = 0
            m.pose.orientation.y = 0
            m.pose.orientation.z = 0
            m.pose.orientation.w = 1
           
            color_red = ColorRGBA()
            color_red.r = 1
            color_red.g = 0
            color_red.b = 0
            color_red.a = 1
            color_blue = ColorRGBA()
            color_blue.r = 0
            color_blue.g = 0
            color_blue.b = 1
            color_blue.a = 1

            p = Point()
            p.x = self.current_pose[0]
            p.y = self.current_pose[1]
            p.z = 0.0
            m.points.append(p)
            m.colors.append(color_blue)
           
            for n in path:
                p = Point()
                p.x = n[0]
                p.y = n[1]
                p.z = 0.0
                m.points.append(p)
                m.colors.append(color_red)
           
            self.marker_pub.publish(m)

    # Publish markers of frontiers          
    def f_marker(self,f,res,orig):
        
        ma = MarkerArray()
        for i in range(len(f)):

            marker = Marker()
            marker.header.frame_id = "world_ned"
            marker.type = marker.SPHERE
            marker.action = marker.ADD

            marker.id = i
            x, y = self.__map_to_position__(f[i],res,orig)
            marker.header.stamp = rospy.Time.now()
            marker.pose.position.x = x
            marker.pose.position.y = y
            
            marker.scale.x = 0.08
            marker.scale.y = 0.08
            marker.scale.z = 0.08

            marker.color.r = 1.0
            marker.color.a = 0.9

            ma.markers.append(marker)
        self.marker_frontier_list_pub.publish(ma)
        print("frontiers published")
    
    # Publish the centroids of each cluster of frontiers
    def f_centroide(self,f,res,orig):
        ma = MarkerArray()
        for i in range(len(f)):

            marker = Marker()
            marker.header.frame_id = "world_ned"
            marker.type = marker.SPHERE
            marker.action = marker.ADD

            marker.id = i
            x, y = self.__map_to_position__(f[i],res,orig)
            marker.header.stamp = rospy.Time.now()
            marker.pose.position.x = x
            marker.pose.position.y = y
            
            marker.scale.x = 0.2
            marker.scale.y = 0.2
            marker.scale.z = 0.2

            marker.color.g = 1
            marker.color.a = 0.9

            ma.markers.append(marker)
        self.marker_centroied_list_pub.publish(ma)
        print("centroieds published\n")

    # Publish the next goal
    def f_goal(self,f,res,orig):
        marker = Marker()
        marker.header.frame_id = "world_ned"
        marker.type = marker.SPHERE
        marker.action = marker.ADD
        x, y = self.__map_to_position__(f,res,orig)
        marker.header.stamp = rospy.Time.now()
        marker.pose.position.x = x
        marker.pose.position.y = y
        
        marker.scale.x = 0.3
        marker.scale.y = 0.3
        marker.scale.z = 0.3

        marker.color.g = 0
        marker.color.r = 0.8
        marker.color.b = 0
        marker.color.a = 0.9

        self.marker_goal_pub.publish(marker)

    # Publish direction of where the robot should traject to
    def best_v_w_marker(self, p):
        print("best (v, w) loaction")
        marker = Marker()
        marker.header.frame_id = "world_ned"
        marker.type = marker.SPHERE
        marker.action = marker.ADD

        # x, y = self.__map_to_position__(f,res,orig)
        # print("aaaaaa", x ,y)
        marker.header.stamp = rospy.Time.now()
        marker.pose.position.x = p[0]
        marker.pose.position.y = p[1]
        
        marker.scale.x = 0.1
        marker.scale.y = 0.1
        marker.scale.z = 0.1

        marker.color.g = 1
        marker.color.r = 0
        marker.color.b = 0.7
        marker.color.a = 1

        self.marker_v_w_pub.publish(marker)

    # Publish the heading of the robot being sent to the DWA algorithm
    def dwa_heading(self, p):
        # p = x, y, theta

        marker = Marker()
        marker.header.frame_id = "world_ned"
        marker.header.stamp = rospy.Time.now()
        marker.ns = "arrow"
        marker.id = 0
        marker.type = Marker.ARROW
        marker.action = Marker.ADD
        marker.pose = Pose(Point(p[0], p[1], 0), Quaternion(0, 0, 0, 1)) 
        marker.scale = Vector3(1, 0.1, 0.1)

        marker.color.a = 1.0  
        marker.color.r = 1.0  
        marker.color.g = 0.0  
        marker.color.b = 0.0  

        # Calculate the arrow's heading
        heading = p[2]
        quaternion = Quaternion()
        quaternion.z = np.sin(heading / 2)
        quaternion.w = np.cos(heading / 2)
        marker.pose.orientation = quaternion

        self.dwa_heading_pub.publish(marker)
    
    # Publish the tree generated by the DWA algorithm
    def dwa_tree(self,p_list):
        ma = MarkerArray()

        for i, p in enumerate(p_list):

            marker = Marker()
            marker.header.frame_id = "world_ned"
            marker.type = marker.SPHERE
            marker.action = marker.ADD

            marker.id = i
            
            marker.header.stamp = rospy.Time.now()
            marker.pose.position.x = p[0]
            marker.pose.position.y = p[1]
            
            marker.scale.x = 0.05
            marker.scale.y = 0.05
            marker.scale.z = 0.05

            marker.color.b = 1
            marker.color.a = 0.9

            ma.markers.append(marker)

        self.dwa_tree_pub.publish(ma)
        #print("dwa tree published\n")
    
    # Publish the direction the DWA is looking at when computing the goal direction
    def dwa_goal_heading(self, p):
        # p = x, y, theta

        marker = Marker()
        marker.header.frame_id = "world_ned"
        marker.header.stamp = rospy.Time.now()
        marker.ns = "arrow"
        marker.id = 0
        marker.type = Marker.ARROW
        marker.action = Marker.ADD
        marker.pose = Pose(Point(p[0], p[1], 0), Quaternion(0, 0, 0, 1)) 
        marker.scale = Vector3(1, 0.1, 0.1)

        marker.color.a = 1.0  
        marker.color.r = 1.0  
        marker.color.g = 0.0  
        marker.color.b = 1.0  

        # Calculate the arrow's heading
        heading = p[2]
        quaternion = Quaternion()
        quaternion.z = np.sin(heading / 2)
        quaternion.w = np.cos(heading / 2)
        marker.pose.orientation = quaternion

        self.dwa_goal_heading_pub.publish(marker)
        
# MAIN FUNCTION
if __name__ == '__main__':
    rospy.init_node('turtlebot_online_path_planning_node')  
    
    node = OnlinePlanner('/projected_map', '/turtlebot/kobuki/ground_truth', '/turtlebot/twist', np.array([-15.0, 15.0]), 0.35)
   
    # Run forever
    rospy.spin()